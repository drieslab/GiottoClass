# Giotto Image Tools

## 1. Overview

Giotto uses `giottoLargeImage` to represent images and raster information. This
is an S4 class built based on the *terra* `SpatRaster`.

An older class called `giottoImage` based on the *magick* package also exists,
but is currently being phased out. Ideally, `giottoLargeImages` will also
be renamed to `giottoImage` afterwards, simplifying the naming scheme.

The object structure of `giottoLargeImage`
```
giottoLargeImage
\- name                (object name)
\- raster_object       (terra raster object)
\- extent              (current spatial extent)
\- overall_extent      (spatial extent of original image - experimental)
\- scale_factor        (pixels per coordinate unit - experimental)
\- resolution          (coordinate units covered per pixel)
\- max_intensity       (approximate maximum intensity value)
\- min_intensity       (approximate minimum intensity value)
\- max_window          (value to set as maximum intensity in color scaling)
\- colors              (vector of color mappings provided as hex codes)
\- is_int              (whether values are integers)
\- file_path           (filepath to the image)
\- OS_platform         (operating system)
```


## 2. Sampling

Spatial images are often extremely large files. The high detail (resolution),
large spatial region captured, and precision of recorded values (bitdepth)
often results in files in the 10s of gigabytes. This makes the full size images
difficult to work with. One way to get around this is to perform regular
sampling of the image, touching only the values of the original image that are
needed generate a downscaled representation. This is implemented in *terra*
as `spatSample()`.

When plotting, *Giotto* optimizes the speed of this sampling by striking a balance
between `terra::crop()` and `terra::spatSample()` to try to prevent sampling from
unnecessary regions, but also avoid large crop operations on the fullsize image,
which can be very costly. This is done through `plot_auto_largeImage_resample()`

`giottoLargeImages` can also be resampled to other image formats (`magick` and 
`EBImage`) in addition to `data.table` and `array` using `GiottoClass:::.spatraster_sample_values()`

These two functions are experimental and they will be exported using more common
function names in the future.

## 3 Color scaling
`distGiottoImage()` can be used to look at the values present within a
`giottoLargeImage`. It is often the case that the values recorded within an
image do not map to the full set of values allowed by its bitdepth.
*Giotto* plots images by guessing the bitdepth based on the estimated maximum
value detected. This mapping may not always be optimal.

```{r}
library(GiottoClass)
gimg <- GiottoData::loadSubObjectMini("giottoLargeImage", idx = 2)
gimg <- GiottoClass:::.update_giotto_image(gimg) # update older images that are missing slots

plot(gimg)
distGiottoImage(giottoLargeImage = gimg)
```

Since there are few values beyond 70, try setting `max_window` to 70 in so
that the color mapping better represents the available information.

```{r}
gimg@max_window <- 70
plot(gimg)
# plot(gimg, max_intensity = 150) # can be used without setting the slot
```


The colormap to use for an image can also be edited. The default for a greyscale
image is a monochrome black to white. Other color scales can be supplied.
For monochrome colorscales: `getMonochromeColors()`
```{r}
gimg@colors <- getMonochromeColors("green")
plot(gimg)
viridis_colors <- hcl.colors(256, palette = "viridis")
plot(gimg, col = viridis_colors) # can be used without setting the slot
```

### TODOs:

- provide accessors for these slots    
- make *ggplot*-based plotting also obey these settings    

```{r}
sessionInfo()
```
