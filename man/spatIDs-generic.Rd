% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods-IDs.R
\name{spatIDs-generic}
\alias{spatIDs-generic}
\alias{spatIDs}
\alias{featIDs}
\alias{spatIDs,giotto-method}
\alias{spatIDs,exprObj-method}
\alias{spatIDs,spatLocsObj-method}
\alias{spatIDs,cellMetaObj-method}
\alias{spatIDs,spatialNetworkObj-method}
\alias{spatIDs,dimObj-method}
\alias{spatIDs,giottoPolygon-method}
\alias{spatIDs,spatEnrObj-method}
\alias{spatIDs,nnNetObj-method}
\alias{featIDs,giotto-method}
\alias{featIDs,exprObj-method}
\alias{featIDs,featMetaObj-method}
\alias{featIDs,giottoPoints-method}
\alias{featIDs,spatEnrObj-method}
\title{Spatial and feature IDs}
\usage{
\S4method{spatIDs}{giotto}(x, spat_unit = NULL, ...)

\S4method{spatIDs}{exprObj}(x, ...)

\S4method{spatIDs}{spatLocsObj}(x, ...)

\S4method{spatIDs}{cellMetaObj}(x, ...)

\S4method{spatIDs}{spatialNetworkObj}(x, ...)

\S4method{spatIDs}{dimObj}(x, ...)

\S4method{spatIDs}{giottoPolygon}(x, use_cache = TRUE, uniques = TRUE, ...)

\S4method{spatIDs}{spatEnrObj}(x, ...)

\S4method{spatIDs}{nnNetObj}(x, ...)

\S4method{featIDs}{giotto}(x, feat_type = NULL, ...)

\S4method{featIDs}{exprObj}(x, ...)

\S4method{featIDs}{featMetaObj}(x, ...)

\S4method{featIDs}{giottoPoints}(x, use_cache = TRUE, uniques = TRUE, ...)

\S4method{featIDs}{spatEnrObj}(x, ...)
}
\arguments{
\item{x}{an object}

\item{spat_unit}{(optional) specify which spatial unit}

\item{...}{additional parameters to pass}

\item{use_cache}{use cached IDs if available (gpoly and gpoints only)}

\item{uniques}{return unique ID values
only (currently gpoly and gpoints only)}

\item{feat_type}{(optional) specify which feature type}
}
\value{
spatIDs and featIDs
}
\description{
Get the cell
IDs (termed spatial IDs to better reflect when not at the single-cell level)
and feature IDs of a giotto object or subobject.

[\strong{\code{giotto} object specific}]
When applied on a \code{giotto} object, these functions pull from the \code{cell_ID}
and \code{feat_ID} slots. The values within these slots are updated whenever the
object is data is changed and, importantly, whenever the active spat_unit and
feat_type is set (see \code{\link[=activeSpatUnit]{activeSpatUnit()}} and \code{\link[=activeFeatType]{activeFeatType()}}). New values
for these slots are specific to the active spat_unit and feat_type and are
detected from either the \emph{subcellular}
level (\code{giottoPolygon} and \code{giottoPoints}) or the \emph{aggregate}
level (expression matrix) data, with a preference for the latter if it
exists. Be aware that with this current behavior, values returned
by\code{spatIDs()} and \code{featIDs()} should be regarded as the minimal set of
expected IDs within all \code{giotto} slots, and not always the exact set or
ordering.
}
\examples{
g <- GiottoData::loadSubObjectMini("giottoPoints")

featIDs(g)
}
