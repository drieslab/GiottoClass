% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods-IDs.R
\name{spatIDs-generic}
\alias{spatIDs-generic}
\alias{spatIDs<-}
\alias{spatIDs}
\alias{featIDs}
\alias{spatIDs,giotto-method}
\alias{spatIDs,exprObj-method}
\alias{spatIDs,spatLocsObj-method}
\alias{spatIDs,cellMetaObj-method}
\alias{spatIDs,spatialNetworkObj-method}
\alias{spatIDs,dimObj-method}
\alias{spatIDs,giottoPolygon-method}
\alias{spatIDs<-,giottoPolygon-method}
\alias{spatIDs,spatEnrObj-method}
\alias{spatIDs,nnNetObj-method}
\alias{featIDs,giotto-method}
\alias{featIDs,exprObj-method}
\alias{featIDs,featMetaObj-method}
\alias{featIDs,giottoPoints-method}
\alias{featIDs,spatEnrObj-method}
\title{Spatial and feature IDs}
\usage{
\S4method{spatIDs}{giotto}(x, spat_unit = NULL, subset, negate = FALSE, quote = TRUE, ...)

\S4method{spatIDs}{exprObj}(x, ...)

\S4method{spatIDs}{spatLocsObj}(x, ...)

\S4method{spatIDs}{cellMetaObj}(x, ...)

\S4method{spatIDs}{spatialNetworkObj}(x, ...)

\S4method{spatIDs}{dimObj}(x, ...)

\S4method{spatIDs}{giottoPolygon}(x, use_cache = TRUE, uniques = TRUE, ...)

\S4method{spatIDs}{giottoPolygon}(x, old = NULL, ...) <- value

\S4method{spatIDs}{spatEnrObj}(x, ...)

\S4method{spatIDs}{nnNetObj}(x, ...)

\S4method{featIDs}{giotto}(x, feat_type = NULL, subset, negate = FALSE, quote = TRUE, ...)

\S4method{featIDs}{exprObj}(x, ...)

\S4method{featIDs}{featMetaObj}(x, ...)

\S4method{featIDs}{giottoPoints}(x, use_cache = TRUE, uniques = TRUE, ...)

\S4method{featIDs}{spatEnrObj}(x, ...)
}
\arguments{
\item{x}{an object}

\item{spat_unit}{(optional) specify which spatial unit}

\item{subset}{logical expression to find a subset of features.}

\item{negate}{logical. if \code{TRUE} all IDs that are \strong{not} in the \code{subset}
are selected}

\item{quote}{logical. If \code{TRUE}, the \code{subset} param will be quoted with
\code{substitute()}. Set this to \code{FALSE} when calling from a function, although
that may not be recommended since NSE output can be unexpected when not used
interactively.}

\item{\dots}{additional params to pass when used with the \code{subset} param.
For \code{spatID()}, these pass to \code{\link[=spatValues]{spatValues()}}. For \code{featID()}, these
currently only pass to \code{fDataDT()}.}

\item{use_cache}{use cached IDs if available (gpoly and gpoints only)}

\item{uniques}{return unique ID values
only (currently gpoly and gpoints only)}

\item{old}{character. IDs to match against to replace}

\item{value}{character. IDs to replace with}

\item{feat_type}{(optional) specify which feature type}
}
\value{
character vector of cell/spatial IDs or feature IDs
}
\description{
Get the cell/spot IDs
(termed spatial IDs to better reflect when not at the single-cell level)
and feature IDs of a giotto object or subobject.

[\strong{\code{giotto} object specific}]
When applied on a \code{giotto} object, these functions pull from the \code{cell_ID}
and \code{feat_ID} slots. The values within these slots are updated whenever the
object is data is changed and, importantly, whenever the active spat_unit and
feat_type is set (see \code{\link[=activeSpatUnit]{activeSpatUnit()}} and \code{\link[=activeFeatType]{activeFeatType()}}). New values
for these slots are specific to the active spat_unit and feat_type and are
detected from either the \emph{subcellular}
level (\code{giottoPolygon} and \code{giottoPoints}) or the \emph{aggregate}
level (expression matrix) data, with a preference for the latter if it
exists. Be aware that with this current behavior, values returned
by\code{spatIDs()} and \code{featIDs()} should be regarded as the minimal set of
expected IDs within all \code{giotto} slots, and not always the exact set or
ordering.
}
\examples{
g <- GiottoData::loadGiottoMini("visium")
spatIDs(g)
spatIDs(g, subset = nr_feats <= 200)
spatIDs(g, subset = Dim.1 > 25, dim_reduction_to_use = "umap")

featIDs(g)
featIDs(g, subset = nr_cells < 100)

gpoints <- GiottoData::loadSubObjectMini("giottoPoints")
featIDs(gpoints)

# ID replacements (currently only giottoPolygons)
polys <- g[["spatial_info"]][[1]]
slot(polys, "overlaps") <- NULL # make NULL to avoid a warning
head(spatIDs(polys))
spatIDs(polys) <- paste0("poly_", seq_len(nrow(polys)))
head(spatIDs(polys))
spatIDs(polys, old = c("poly_1", "poly_3")) <- c("test1", "test2")
head(spatIDs(polys))
}
