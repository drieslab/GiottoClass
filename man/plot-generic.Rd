% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods-plot.R
\name{plot-generic}
\alias{plot-generic}
\alias{plot}
\alias{plot,giottoImage,missing-method}
\alias{plot,giottoLargeImage,missing-method}
\alias{plot,giottoAffineImage,missing-method}
\alias{plot,giottoPolygon,missing-method}
\alias{plot,giottoPoints,missing-method}
\alias{plot,spatLocsObj,missing-method}
\alias{plot,dimObj,missing-method}
\alias{plot,spatialNetworkObj,missing-method}
\alias{plot,affine2d,missing-method}
\title{Preview a Giotto spatial object}
\usage{
\S4method{plot}{giottoImage,missing}(x, y, ...)

\S4method{plot}{giottoLargeImage,missing}(
  x,
  y,
  col,
  max_intensity,
  mar,
  asRGB = FALSE,
  legend = FALSE,
  axes = TRUE,
  maxcell = 5e+05,
  smooth = TRUE,
  ...
)

\S4method{plot}{giottoAffineImage,missing}(x, y, ...)

\S4method{plot}{giottoPolygon,missing}(
  x,
  point_size = 0.6,
  type = c("poly", "centroid"),
  max_poly = getOption("giotto.plot_max_poly", 10000),
  ...
)

\S4method{plot}{giottoPoints,missing}(x, point_size = 0, feats = NULL, raster = TRUE, raster_size = 600, ...)

\S4method{plot}{spatLocsObj,missing}(x, y, ...)

\S4method{plot}{dimObj,missing}(x, dims = c(1, 2), ...)

\S4method{plot}{spatialNetworkObj,missing}(x, y, ...)

\S4method{plot}{affine2d,missing}(x, y, ...)
}
\arguments{
\item{x}{giotto image, giottoPolygon, or giottoPoints object}

\item{y}{Not used.}

\item{\dots}{additional parameters to pass}

\item{col}{character. Colors. The default is grDevices::grey.colors(n = 256, start = 0, end = 1, gamma = 1)}

\item{max_intensity}{(optional) value to treat as maximum intensity in color scale}

\item{mar}{numeric vector of length 4 to set the margins of the plot (to make space for the legend). The default is (3, 5, 1.5, 1)}

\item{asRGB}{(optional) logical. Force RGB plotting if not automatically detected}

\item{legend}{logical or character. If not FALSE a legend is drawn. The character value can be used to indicate where the legend is to be drawn. For example "topright" or "bottomleft"}

\item{axes}{logical. Draw axes?}

\item{maxcell}{positive integer. Maximum number of cells to use for the plot}

\item{smooth}{logical. If TRUE the cell values are smoothed}

\item{point_size}{size of points when plotting giottoPoints}

\item{type}{what to plot: either 'poly' (default) or polygon 'centroid'}

\item{max_poly}{numeric. If \code{type} is not specified, maximum number of
polygons to plot before automatically switching to centroids plotting.
Default is 1e4. This value is settable using options("giotto.plot_max_poly")}

\item{feats}{specific features to plot within giottoPoints object
(defaults to NULL, meaning all available features)}

\item{raster}{default = TRUE, whether to plot points as rasterized plot with
size based on \code{raster_size} param. See details. When \code{FALSE}, plots via
\code{\link[terra:plot]{terra::plot()}}}

\item{raster_size}{Default is 600. Only used when \code{raster} is TRUE}

\item{dims}{dimensions to plot}
}
\value{
plot
}
\description{
S4 generic for previewing Giotto's image and subcellular
objects.
}
\details{
\emph{[giottoPoints raster plotting]}
Fast plotting of points information by rasterizing the information using
\code{\link[terra:rasterize]{terra::rasterize()}}. For \pkg{terra} \code{SpatVectors}, this is faster than
\pkg{scattermore} plotting. When plotting as a raster, \code{col} colors map on
whole image level, as opposed to mapping to individual points, as it does
when \code{raster = FALSE}
Allows the following additional params when
plotting with no specific \code{feats} input:
\itemize{
\item \strong{force_size} logical. \code{raster_size} param caps at 1:1 with the
spatial extent, but also with a minimum resulting px dim of 100. To ignore
these constraints, set \code{force_size = FALSE}
\item \strong{dens} logical. Show point density using \code{count} statistic per
rasterized cell. (Default = FALSE). This param affects \code{col} param is
defaults. When TRUE, \code{col} is \code{grDevices::hcl.colors(256)}. When \code{FALSE},
"black" and "white" are used.
\item \strong{background} (optional) background color. Usually not used when a
\code{col} color mapping is sufficient.
}

Note that \code{col} param and other \code{\link[base:plot]{base::plot()}} graphical params are available
through \code{...}
}
\section{Functions}{
\itemize{
\item \code{plot(x = giottoImage, y = missing)}: Plot \emph{magick}-based giottoImage object. ... param passes to \code{\link{.plot_giottoimage_mg}}

\item \code{plot(x = giottoLargeImage, y = missing)}: Plot \emph{terra}-based giottoLargeImage object. ... param passes to \code{\link{.plot_giottolargeimage}}

\item \code{plot(x = giottoPolygon, y = missing)}: Plot \emph{terra}-based giottoPolygon object. ... param passes to \code{\link[terra]{plot}}

\item \code{plot(x = giottoPoints, y = missing)}: \emph{terra}-based giottoPoint object. ... param passes to \code{\link[terra]{plot}}

\item \code{plot(x = spatLocsObj, y = missing)}: Plot a spatLocsObj

\item \code{plot(x = dimObj, y = missing)}: Plot a dimObj

\item \code{plot(x = spatialNetworkObj, y = missing)}: Plot a spatialNetworkObj

\item \code{plot(x = affine2d, y = missing)}: Plot a affine2d. blue is start, red is end

}}
\examples{
######### giottoLargeImage plotting #########
\dontrun{
gimg <- GiottoData::loadSubObjectMini("giottoLargeImage")
gimg <- GiottoClass:::.update_giotto_image(gimg) # only needed if out of date
plot(gimg)
plot(gimg, col = grDevices::hcl.colors(256))
plot(gimg, max_intensity = 100)
}

######### giottoPolygon plotting #########
gpoly <- GiottoData::loadSubObjectMini("giottoPolygon")
plot(gpoly)
plot(gpoly, type = "centroid")

######### giottoPoints plotting #########
gpoints <- GiottoData::loadSubObjectMini("giottoPoints")

# ----- rasterized plotting ----- #
# plot points binary
plot(gpoints)
# plotting all features maps colors on an image level
plot(gpoints, col = grDevices::hcl.colors(n = 256)) # only 2 colors are used
plot(gpoints, col = "green", background = "purple")

# plot points density (by count)
plot(gpoints, dens = TRUE, raster_size = 300)

# force_size = TRUE to ignore default constraints on too big or too small
# (see details)
plot(gpoints, dens = TRUE, raster_size = 80, force_size = TRUE)

# plot specific feature(s)
plot(gpoints, feats = featIDs(gpoints)[seq_len(4)])

# ----- vector plotting ----- #
# non-rasterized plotting (slower, but higher quality)
plot(gpoints, raster = FALSE)

# vector plotting maps colors to transcripts
plot(gpoints, raster = FALSE, col = grDevices::rainbow(nrow(gpoints)))

# plot specific feature(s)
plot(gpoints, feats = featIDs(gpoints)[seq_len(4)], raster = FALSE)

######### spatLocsObj plotting #########
sl <- GiottoData::loadSubObjectMini("spatLocsObj")
plot(sl)

######### dimObj plotting #########
d <- GiottoData::loadSubObjectMini("dimObj")
plot(d)
plot(d, dims = c(3, 5))

}
\concept{plot}
