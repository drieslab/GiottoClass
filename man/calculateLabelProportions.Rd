% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/combine_metadata.R
\name{calculateLabelProportions}
\alias{calculateLabelProportions}
\title{Calculate Proportions of Labels Per Observation Group}
\usage{
calculateLabelProportions(
  gobject,
  labels,
  group_method = c("table", "spatialnetwork", "polygon"),
  groups = NULL,
  column_cell_id = "cell_ID",
  column_group_id = NULL,
  spatial_network_name = NULL,
  alpha = 1,
  weights = FALSE,
  spat_info,
  select_on = c("spatial_locs", "polygons"),
  centroids = TRUE,
  spat_loc_name = NULL,
  name = "proportions",
  spat_unit = NULL,
  feat_type = NULL,
  output = c("data.table", "matrix", "spatEnrObj", "gobject"),
  verbose = NULL
)
}
\arguments{
\item{gobject}{giotto object}

\item{labels}{character. Metadata column gobject with labels to use}

\item{group_method}{character, one of \code{"table"}, \code{"spatialnetwork"},
\code{"polygon"}. Method used to find groups of cell_IDs to perform proportion
calculation on. See description.}

\item{groups}{character or data.frame. If character, groups are assumed to
be a metadata column to use. If data.frame, a 2 column table of relations
between groups and cell_IDs in those groups. The values of group column will
be used as the group names.}

\item{column_cell_id}{character. Name of column in \code{groups} that contains
cell_ID values to use.}

\item{column_group_id}{character. Name of column in \code{groups} that contains
the group ids. If not provided, the first character col in \code{groups} that is
not \code{column_cell_id} will be used.}

\item{spatial_network_name}{character. Name of spatial network to use to
group cell_ID values to use.}

\item{alpha}{numeric. Value between 0 and 1 inclusive that defines weighting
for self-self network connections.}

\item{weights}{logical. Whether to use the \code{"weight"} information included
with spatial networks as part of the proportions calculation.}

\item{spat_info}{character. Name of polygon information to use to group}

\item{select_on}{character. One of \code{"spatial_locs"} or \code{"polygons"}. Whether
to perform the polygon grouping on the spatial locations information or the
polygons.}

\item{centroids}{logical. When \code{select_on = "polygons"}, whether to use
the polygon centroids instead of the polygon for the spatial intersects
operation.}

\item{spat_loc_name}{character. Name of spatial locations to use in
spatial intersects operation.}

\item{name}{character. Name to assign to the \code{spatEnrObj} results if \code{output}
is either \code{"spatEnrObj"} or \code{"gobject"}.}

\item{spat_unit}{spatial unit to perform grouping selection and calculation
on.}

\item{feat_type}{feature type (e.g. "rna", "dna", "protein")}

\item{output}{character. Type of data to return. One of \code{"data.table"},
\code{"matrix"}, \code{"gobject"}, or \code{"spatEnrObj"}}

\item{verbose}{verbosity.}
}
\value{
\code{gobject} with \code{spatEnrObj} of results attached, \code{data.table},
\code{matrix}, or \code{spatEnrObj} depending on \code{output} param.
}
\description{
Calculate a proportion table for a cell metadata column
(e.g. celltype labels) based on defined groupings of cells. These groups
can be defined in one of 3 ways:
\itemize{
\item \code{"table"} - explicitly provide a \code{data.frame} of relationships between a
grouping column and cell IDs or provide a colname in cell metadata with
grouping information. Method-specific params are:
\itemize{
\item \code{groups} - the \code{data.frame} or \code{character} input
\item \code{column_group_id} - column in \code{groups} defining the groups
\item \code{column_cell_id} - column in \code{groups} defining the grouped cell_IDs
}
\item \code{"spatialnetwork"} - Use a spatial network to find groups of cells, where
the groups are the cells and their network neighbors. Method-specific params
are:
\itemize{
\item \code{spatial_network_name} - name of spatial network to use
\item \code{weights} - whether to consider proportion contribution of neighbors
based on network weights (\code{TRUE}) or adjacency (\code{FALSE})
\item \code{alpha} - weighting between 0 and 1 to use for the cell itself. This is
independent from the \code{weights} param.
}
\item \code{"polygon"} - Use a set of polygons indicated using \code{spat_info} to select
underlying cells of the \code{spat_unit}. This is determined with
\code{relate(relation = "intersects")}, where the underlying cells may be
represented by either the polygons, their centroids, if \code{centroids = TRUE},
or the spatial locations if a specific \code{spat_loc_name} is provided.
\itemize{
\item \code{spat_info} - name of polygons to select with.
\item \code{select_on} - one of \code{"spatial_locs"} or \code{"polygons"}, determining
whether the cells to be selected will be represented by their spatial
locations (further specified via \code{spat_loc_name}) or their polygons.
\item \code{centroids} - if \code{select_on = "polygons"}, further specify whether to
perform selection on polygon centroids.
\item \code{spat_loc_name} - if \code{select_on = "spatial_locs"}, further specify the
set of spatial locations to use.
}
}
}
\examples{
g <- GiottoData::loadGiottoMini("vizgen")
activeSpatUnit(g) <- "aggregate"
rels <- data.frame(
    grp = rep(LETTERS[1:10], length.out = ncol(g)),
    cid = colnames(g)
)
# calculate and return as data.table
calculateLabelProportions(g,
    labels = "leiden_clus", groups = rels, column_cell_id = "cid",
    spat_unit = "aggregate", output = "data.table"
)
# return as matrix
calculateLabelProportions(g,
    labels = "leiden_clus", groups = rels, column_cell_id = "cid",
    spat_unit = "aggregate", output = "matrix"
)
# calculate with groups from another column in metadata
calculateLabelProportions(g,
    labels = "louvain_clus", groups = "leiden_clus",
    spat_unit = "aggregate", output = "matrix"
)
# calculate proportions across all cells
calculateLabelProportions(g,
    labels = "leiden_clus",
    groups = data.frame(
        id = "all", # this is an arbitrary name
        cell_ID = colnames(g)
    ),
    spat_unit = "aggregate",
    output = "matrix"
)

# network
g <- createSpatialNetwork(g,
    name = "knn_k8_r30",
    maximum_distance_knn = 30,
    k = 8
 )
calculateLabelProportions(g, labels = "leiden_clus",
    group_method = "spatialnetwork", spatial_network_name = "knn_k8_r30",
    spat_unit = "aggregate", output = "spatEnrObj"
)
# add to gobject
g <- calculateLabelProportions(g, labels = "leiden_clus",
    group_method = "spatialnetwork", spatial_network_name = "knn_k8_r30",
    spat_unit = "aggregate", output = "gobject"
)
# with weighted contributions and alpha = 0 (no self-self contribution)
g <- calculateLabelProportions(g, labels = "leiden_clus",
    group_method = "spatialnetwork", spatial_network_name = "knn_k8_r30",
    spat_unit = "aggregate", output = "gobject", alpha = 0, weights = TRUE
)

# polygon
hex <- tessellate(
    extent = ext(g), shape = "hexagon", shape_size = 20, gap = -5,
    name = "hex"
)
g <- setGiotto(g, hex)
g <- calculateLabelProportions(g, labels = "leiden_clus",
    group_method = "polygon", spat_info = "hex",
    spat_unit = "aggregate", output = "gobject"
)
}
