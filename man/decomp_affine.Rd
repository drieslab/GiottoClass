% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/methods-affine.R
\name{decomp_affine}
\alias{decomp_affine}
\alias{.decomp_affine}
\title{Decompose affine matrix into scale, rotation, and shear operations}
\usage{
.decomp_affine(x)
}
\arguments{
\item{x}{object coercible to matrix with a 2x3 or 3x3 affine matrix}
}
\value{
a list of transforms information.
}
\description{
Affine transforms are linear transformations that cover scaling,
rotation, shearing, and translations. They can be represented as matrices of
2x3 or 3x3 values. This function reads the matrix and extracts the values
needed to perform them as a list of class \code{affine}. Works only for 2D
transforms. Logic from \url{https://math.stackexchange.com/a/3521141}
}
\examples{
# load example data
sl <- GiottoData::loadSubObjectMini("spatLocsObj")

# affine transform matrices
m <- diag(rep(1, 3))
shear_m <- trans_m <- m
trans_m[seq(2), 3] <- c(200, 300)
scale_m <- diag(c(2, 3, 1))
shear_m[2, 1] <- 2
aff_m <- matrix(c(
    2, 0.5, 1000, 
    -0.3, 3, 20,
    100, 29, 1
), nrow = 3, byrow = TRUE)

# create affine objects
# values are shown in order of operations
affine(m)
affine(trans_m)
affine(scale_m)
s <- affine(shear_m)
a <- affine(aff_m)
force(a)

# perform piecewise transforms with decomp

sl_shear_piecewise <- sl |>
    spin(GiottoUtils::degrees(s$rotate), x0 = 0, y0 = 0) |>
    shear(fx = s$shear[["x"]], fy = s$shear[["y"]], x0 = 0, y0 = 0) |>
    rescale(fx = s$scale[["x"]], fy = s$scale[["y"]], x0 = 0, y0 = 0) |>
    spatShift(dx = s$translate[["x"]], dy = s$translate[["y"]])

sl_aff_piecewise <- sl |>
    spin(GiottoUtils::degrees(a$rotate), x0 = 0, y0 = 0) |>
    shear(fx = a$shear[["x"]], fy = a$shear[["y"]], x0 = 0, y0 = 0) |>
    rescale(fx = a$scale[["x"]], fy = a$scale[["y"]], x0 = 0, y0 = 0) |>
    spatShift(dx = a$translate[["x"]], dy = a$translate[["y"]])
    
plot(affine(sl, shear_m))
plot(sl_shear_piecewise)
plot(affine(sl, aff_m))
plot(sl_aff_piecewise)

}
\keyword{internal}
