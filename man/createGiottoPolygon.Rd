% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/create.R
\name{createGiottoPolygon}
\alias{createGiottoPolygon}
\alias{createGiottoPolygon,character-method}
\alias{createGiottoPolygon,SpatVector-method}
\alias{createGiottoPolygon,SpatRaster-method}
\alias{createGiottoPolygon,data.frame-method}
\alias{createGiottoPolygonsFromMask}
\alias{createGiottoPolygonsFromDfr}
\alias{createGiottoPolygonsFromGeoJSON}
\title{Create giotto polygons object}
\usage{
\S4method{createGiottoPolygon}{character}(
  x,
  remove_background_polygon = TRUE,
  background_algo = "range",
  make_valid = FALSE,
  verbose = TRUE,
  ...
)

\S4method{createGiottoPolygon}{SpatVector}(x, name = "cell", calc_centroids = FALSE, verbose = TRUE)

\S4method{createGiottoPolygon}{SpatRaster}(
  x,
  name = "cell",
  mask_method = c("guess", "single", "multiple"),
  remove_background_polygon = FALSE,
  background_algo = c("range"),
  fill_holes = TRUE,
  poly_IDs = NULL,
  ID_fmt = "cell_",
  flip_vertical = FALSE,
  shift_vertical_step = FALSE,
  flip_horizontal = FALSE,
  shift_horizontal_step = FALSE,
  remove_unvalid_polygons = TRUE,
  calc_centroids = FALSE,
  verbose = TRUE
)

\S4method{createGiottoPolygon}{data.frame}(
  x,
  name = "cell",
  part_col = NULL,
  calc_centroids = FALSE,
  skip_eval_dfr = FALSE,
  copy_dt = TRUE,
  verbose = TRUE,
  make_valid = FALSE,
  ...
)

createGiottoPolygonsFromMask(
  maskfile,
  mask_method = c("guess", "single", "multiple"),
  name = "cell",
  remove_background_polygon = TRUE,
  background_algo = c("range"),
  fill_holes = TRUE,
  poly_IDs = NULL,
  ID_fmt = "cell_",
  flip_vertical = FALSE,
  shift_vertical_step = FALSE,
  flip_horizontal = FALSE,
  shift_horizontal_step = FALSE,
  calc_centroids = FALSE,
  remove_unvalid_polygons = TRUE,
  verbose = FALSE
)

createGiottoPolygonsFromDfr(
  segmdfr,
  name = "cell",
  part_col = NULL,
  calc_centroids = FALSE,
  make_valid = FALSE,
  verbose = TRUE,
  skip_eval_dfr = FALSE,
  copy_dt = TRUE
)

createGiottoPolygonsFromGeoJSON(
  GeoJSON,
  name = "cell",
  calc_centroids = FALSE,
  make_valid = FALSE,
  remove_background_polygon = TRUE,
  background_algo = "range",
  verbose = TRUE
)
}
\arguments{
\item{x}{input. Filepath to a .GeoJSON or a mask image file. Can also be a
data.frame with vertex 'x', 'y', and 'poly_ID' information.}

\item{remove_background_polygon}{try to remove background
polygon (default: TRUE)}

\item{background_algo}{algorithm to remove background polygon}

\item{make_valid}{logical. (default \code{FALSE}) Whether to run
\code{\link[terra:is.valid]{terra::makeValid()}} on the geometries. Setting this to \code{TRUE} may cause
read-in polygon attribute information to become out of sync.}

\item{verbose}{be verbose}

\item{\dots}{additional params to pass. For character method, params pass to
SpatRaster or SpatVector methods, depending on whether x was a filepath to
a maskfile or a spatial file (ex: wkt, shp, GeoJSON) respectively.}

\item{name}{character. Name to assign this set of polygons. This will also
be the name of the spatial unit that they define. See \link{giotto_schema}}

\item{calc_centroids}{logical. (default \code{FALSE}) calculate centroids for
polygons}

\item{mask_method}{how the mask file defines individual segmentation
annotations. See \emph{mask_method} section}

\item{fill_holes}{fill holes within created polygons}

\item{poly_IDs}{character vector. Default = NULL. Custom unique names for
each polygon in the mask file.}

\item{ID_fmt}{character. Only applied if \code{poly_IDs = NULL}. Naming scheme for
poly_IDs. Default = "cell_". See \emph{ID_fmt} section.}

\item{flip_vertical, flip_horizontal}{logical. Flip output polygons across y
(vertical) or x (horizontal) axis.}

\item{shift_vertical_step, shift_horizontal_step}{logical or numeric. When
\code{FALSE}, no shift is performed. When numeric, a shift of
\eqn{image height \times step} (vertical) or \eqn{image width \times step}
(horizontal) is performed.}

\item{remove_unvalid_polygons}{remove unvalid polygons (default: TRUE)}

\item{part_col}{character (optional). If provided, a column in the data
when processing will be indexed along as parts to generate a multipolygon.}

\item{skip_eval_dfr}{logical. (default FALSE) skip evaluation of provided
dataframe}

\item{copy_dt}{(default TRUE) if segmdfr is provided as dt, this determines
whether a copy is made}

\item{maskfile}{path to mask file, a terra \code{SpatRaster}, or some other
data class readable by \code{\link[terra:rast]{terra::rast()}}}

\item{segmdfr}{data.frame-like object with polygon coordinate
information (x, y, poly_ID) with x and y being vertex information for the
polygon referenced by poly_ID. See details for how columns are selected for
coordinate and ID information.}

\item{GeoJSON}{path to .GeoJSON file}
}
\value{
giottoPolygon
}
\description{
Create a \code{giottoPolygon} object that is used to represent
spatial annotations and polygons. Inputs can be from a structured data.frame
object where three of the columns should correspond to x/y vertices and the
polygon ID and additional columns are set as attributes, a spatial file
such as wkt, .shp, or .GeoJSON, or a mask file (e.g. segmentation results).
\cr
The character method is for file reading and will dispatch to specific
methods based on what kind of data the file was.
}
\details{
When determining which column within tabular data is intended to
provide polygon information, Giotto first checks the column names for 'x',
'y', and 'poly_ID'. If any of these are discovered, they are directly
selected. If this is not discovered then Giotto checks the data type of the
columns and selects the first \code{'character'} type column to be 'poly_ID' and
the first two \code{'numeric'} columns as 'x' and 'y' respectively. If this is
also unsuccessful then poly_ID defaults to the 3rd column. 'x' and 'y' then
default to the 1st and 2nd columns.
}
\section{mask_method}{

One of "single", "multiple", or "guess".
\itemize{
\item{\emph{"single"} assumes that the provided mask image is binary, with only
polygon vs background being distinct values. With this kind of image, the
expected generated polygons is a single multipart polygon. "single" takes
this multipart polygon and breaks it apart into individual singlepart
polygons. An initial simple \code{numeric} index as the 'nth' polygon found in
the mask image will be applied as an ID (see \emph{ID_fmt} section).}
\item{\emph{"multiple"} assumes that the provided mask image has distinct
intensity values to specify the IDs of individual polygons. An initial
\code{numeric} ID is applied as the intensity value of the pixels that made up
the annotation for that polygon in the mask image (see \emph{ID_fmt} section).}
\item{\emph{"guess"} examines the values in the image to pick the most likely
appropriate method out of "single" or "multiple".}
}
}

\section{ID_fmt}{

Defaults to applying the input as a prefix (using \code{paste0()}) to the
numerical ID values detected by  \code{mask_method}. (ie: \code{ID_fmt = "cell_"}
produces \code{cell_1}, \code{cell_2}, \code{cell_3}, ...)\cr
If a "\%" character is detected in the input then the input will be treated as
a \code{sprintf()} \code{fmt} param input instead. (ie: \code{ID_fmt = "cell_\%03d"} produces
\code{cell_001}, \code{cell_002}, \code{cell_003}, ...)
}

\examples{
# ------- create from a mask image ------- #
# example multi-value mask image
mask_multi <- system.file("extdata/toy_mask_multi.tif",
    package = "GiottoClass"
)
plot(terra::rast(mask_multi), col = grDevices::hcl.colors(7)) # preview mask
createGiottoPolygon(mask_multi) # with all default settings
gpoly1 <- createGiottoPolygon(mask_multi,
    ID_fmt = "id_test_\%03d", # apply a format when assigning poly_IDs
    name = "multi_test"
)
force(gpoly1)
plot(gpoly1, col = grDevices::hcl.colors(7)) # plot poly

# example single-value mask image
mask_single <- system.file("extdata/toy_mask_single.tif",
    package = "GiottoClass"
)
plot(terra::rast(mask_single)) # preview mask

gpoly2 <- createGiottoPolygon(mask_single,
    ID_fmt = "id_test_\%03d",
    name = "single_test"
)
plot(gpoly2, col = grDevices::hcl.colors(5)) # plot poly

# ------- create from an shp file ------- #
shp <- system.file("extdata/toy_poly.shp", package = "GiottoClass")
# vector inputs do not have params for flipping and shifting
gp2 <- createGiottoPolygon(shp)
plot(gp2, col = grDevices::hcl.colors(7))

# ------- create from data.frame-like ------- #
# load example data and convert to data.table
dt <- data.table::data.table(
    id = c(
        rep('a', 3), # Triangle (id 'a')
        rep('b', 4), # Square 1 (id 'b')
        rep('c', 4) # Square 2 (id 'c')
    ),
    x = c(
        0, 1, 0.5,
        2, 5, 5, 2,
        6, 7, 7, 6
    ),
    y = c(
        0, 0, 1,
        2, 2, 5, 5,
        5, 5, 6, 6
    )
)

# simple polygons only need 3 cols
force(dt)
out1 <- createGiottoPolygon(dt)
plot(out1, col = getRainbowColors(3))

# multipolygons can be generated using the `part_col` param
dt[, part_index := c(rep(1, 7), rep(2, 4))]
dt[, id := c(rep("a", 3), rep("b", 8))]
force(dt)
out2 <- createGiottoPolygon(dt, part_col = "part_index")
plot(out2, col = getRainbowColors(2))

# For more complex inputs with holes, it is recommended to format into
# the geom, part, x, y, hole, format that terra uses with matrix inputs
# + poly_ID.

# extract 5 column representation:
dt_full <- data.table::as.data.table(out2, geom = "XY")
force(dt_full)

# Columns named geom, part, x, y, hole, are treated specially when provided.
# They can be directly used without internal modification
res <- createGiottoPolygon(dt_full)
plot(res, col = getRainbowColors(2))

# additional columns outside of the 3 (+ part_col if provided) or 5 column
# formatting are retained as attributes
# These cols MUST map with the poly_ID/geom.

# set up an example attribute
dt_full$attribute <- match(dt_full$poly_ID, letters)
createGiottoPolygon(dt_full)
}
\concept{mask polygon}
\concept{polygon}
